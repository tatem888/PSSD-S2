Problem Solving and Software Development S2 2024

Logbook - Tate Manning - a1821633

Week 7

Problem 1 - PrefixFreeSets - Bonus Problem

I decided to attempt the bonus problem first

I started out confused by the questios definitions of sufix free sets but once i had worked it out, i knew that i needed to check all of the possible pairs of words to see if there were forbidden.

Using this, i could check all the pairs in nlog(n) time as each pair didnt matter which word comes first, you just need to check that the shorter of the two words is not a rpefix of the other.
By collecting the valid pairs in a table of all combinations, i could then check the table find which word was compatible with the most other words, making the largest subset.

I realised that my logic was flawed and that i actually needed to compare not just pairs of words butcompare a new word to the full set so i decided to implement the code by creating a subset for each word in the original set, and going through and adding other words if they still fit the set 

During implementing, I worked out that if sorted alphabetically, the list of words only needed to be checked against the next word in the list. 
If a word was a prefix of a word following it, then it wouldnt be added to the best set, and if it wasnt a prefix, it was added to the best set. The last word in the set would always be in the best set as it alphabetically cannot be the prefix of any word
Then i could just find the length of the best set and return it.

I was glad to have found this solution to the problem, as it made the coding process alot simpler, giving me an impletation with minimal loops and comparisons. I used a helper function to help keep the main function clean, and required little revision and bugfinding due to the simple nature of the code.
In the future I am aiming to look for more elegent solutions to problems, to help make my job of coding easier and reducing the time i need to find bugs.


Problem 2 - FairWorkload

i initially wanted to implement a greedy algorithm that would simply iterate through the algorithm and allocate cabinets to a worker until the sum of folders in their partition exceeded the average expected folders (total number of folders divided by workers), but i realised in some cases this wouldnt return optimal and it would be difficult to ensure the correect number of partitions were made
since it is a problem of optimising the woarkload so the maximum workload recieved is minimised, i thought of ways i could use a binary search on the searchspace of possible maximum workloads. I know that the minimum workload is just the largest single cabinet, and the maximum searchload is if one candidate handled all the cabinets..
by going to the middle of the searchspace with each check, and testing if it is possible to partition the group with each worker having less than the maximum workload, i could efficiently search and find my optimised solution.
I would also then be able to use the greedy search that i initially though of to check if each partition is valid. if the partition was valid with the number of workers, then i would know that i can lower the maximum, if it was invalid due, i would be able to look higher inn the search to my current point

After some small bugs in my code were fixed this solution worked. I was also happy with the timeframe in which i completed the question, and i feel that under exam conditions i could have done similarly well.
I am feeling more confident in my ability to solve problems under time pressure, which is something i think i have struggled most with during the exams. I think thinking more about the other types of data structures and algorithms that i can use has helped with this.

Problem 3 - Minimal difference

I picked this problem as an easier one that i am going to test myself to do under a time constraint. I will allow myself an hour to complete the problem initially, similar to the timeframe i would have under exam conditions

My first thought is that i can see a fairly simple brute force solution where i firstly calculate the digit sum as i iterate the values between a and b, and keep track of the value closest to C. There may be another way to approach the question
but for now i am going to go with this approach becasue it is solution i am very familiar with and i wasnt to complete it in a quick manner.

i was able to complete my solution within the timeframe that i set, and while it was not some of the most readable code, which sometimes made it hard to debug and verify, i was focusing on my time to complete the solution so i am happy with the result


Reflection
This week i again focused on my ability to create solutions under time pressure, focusing less on the optimal implementation and just getting a solution that worked. While this isnt always going to be the best way to approach coding 
i felt that my biggest downfall in the last exam was focusing too much on an elegant solution rather than a working one, and by practicing this i was able to improve on my speed. In time as i practice more, better solutions will be easier for me to code with the same speed,
but that is something i can continue to practice



